#include <mex.h>
#include <math.h>



inline double getSign(double x) { 
    return double((0 < x) - (x < 0)); 
}

void computeFractionalPixel(double *points, int pointsNumber, double de1, int nextP1I, int p1I, double *p1)
{
    double dp1[2];
    const double SQRT2 = 1.414213562373095;
    for(int j = 0; j<2; j++){
        //mexPrintf("%f, %f\n", points[nextP1I + j*pointsNumber], points[p1I + j*pointsNumber]);
        dp1[j] = points[nextP1I + j*pointsNumber] - points[p1I + j*pointsNumber];
    }
    //mexPrintf("%f, %f\n", dp1[0], dp1[1]);
    
    if ((dp1[0] == 0) || (dp1[1] == 0))
    {
        for(int j = 0; j<2; j++)
            p1[j] = de1*getSign(dp1[j]) + points[p1I + j*pointsNumber];
        //mexPrintf("1) %f, %f \n", p1[0], p1[1]);
        //mexPrintf("%f, %f, %f, %f\n", de1, points[p1I + 0*pointsNumber], dp1[0], getSign(dp1[0]));//de1, , );
    }
    else
    {
        if ((abs(dp1[0]) == 1) && (abs(dp1[1]) == 1))
        {
            for(int j = 0; j<2; j++)
                p1[j] = points[p1I + j*pointsNumber] + (dp1[j] * de1 / SQRT2);
            //mexPrintf("2) %f, %f\n", p1[0], p1[1]);
        }
        else
        {
            double r;
            r = (dp1[1] / dp1[0]);
            double dy1 = de1 / sqrt(1 +  r*r);
            r = (dp1[0] / dp1[1]);
            double dx1 = de1 / sqrt(1 +  r*r);
            p1[0] = dy1 * getSign(dp1[0]) + points[p1I]; //points(p1I,0)
            p1[1] = dx1 * getSign(dp1[1]) + points[p1I + pointsNumber]; //points(p1I,1)
            
            //mexPrintf("3) %f, %f\n", p1[0], p1[1]);
        }
    }
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
//   Inputs:
//    points M_PI          - the vector of clockwise, circularly-connected
//                          points ((x,y) pairs).
//       edgeLength       - the length of edges from the angle vertex.
//       chainCodeLengths - the chain-code length at each point;
//                          if empty, the array indices are used instead
//   Output:
//       angles - the angles of curvature per point (0 = none to +-180 =
//                maximum curvature). The sign represents whether the angle
//                is convex (+) or concave (-).  

    // input. note: (double *)mxGetData() and mxGetPr() are equivalent
    double *points = (double *)mxGetData(prhs[0]); 
    mwSize pointsNumber = mxGetM(prhs[0]);
    int lastArrayIndex = (pointsNumber-1);
    double *ptrEdgeLength = (double *)mxGetData(prhs[1]);
    double edgeLength = ptrEdgeLength[0];
    double *chainCodeLengths = (double *)mxGetData(prhs[2]);
    
    //output
    plhs[0] = mxCreateNumericMatrix(pointsNumber,1,mxDOUBLE_CLASS,mxREAL);
    double *angles = mxGetPr(plhs[0]);
    
    // Compute the curvature using the chain-code lengths.
    int p1I = lastArrayIndex;
    int pvI = 0;
    double pvLength = chainCodeLengths[p1I] + chainCodeLengths[pvI];
    double e1 = pvLength - chainCodeLengths[p1I];
    while ((p1I > 0) && (e1 < edgeLength))
    {
        p1I = p1I - 1;
        e1 = pvLength - chainCodeLengths[p1I];
    }
    //mexPrintf("e1 = %f\n", e1);
    //mexPrintf("p1I = %i\n", p1I);
    
    //Compute the angles.
    int p2I = pvI;
    double e2;
    
    int nextE1, nextP1I, prevP2I;
    double de1, de2;
    double p1[2], p2[2];
    double a1,a2;
    
    int tot = 0;
    while (pvI < pointsNumber)
    {
        tot++;
        if (tot > 10)
                return;
        // Compute the second edge length.
        if (p2I >= pvI)
            e2 = chainCodeLengths[p2I] - chainCodeLengths[pvI];
        // Compute the wrapped, second edge length.
        else
            e2 = chainCodeLengths[pointsNumber-1] + chainCodeLengths[p2I] - chainCodeLengths[pvI];
        
        // Find the second edge.
        while (e2 < edgeLength)
        {
            p2I = p2I + 1;
            // Wrap.
            if (p2I > lastArrayIndex)
                p2I = p2I - lastArrayIndex;
            
            // Compute the second edge length.
            if (p2I >= pvI)
                e2 = chainCodeLengths[p2I] - chainCodeLengths[pvI];   
            // Compute the wrapped, second edge length.
            else
                e2 = chainCodeLengths[pointsNumber-1] + chainCodeLengths[p2I] - chainCodeLengths[pvI];
        }
        /*
         *% Compute fractional pixels for the first edge.
        % Note: the first edge is equal to or just over the requested edge
        % length. Therefore, the fractional pixels for the requested length
        % lie on the line separating point 1 (index = p1I) from the next
        % closest point to the vertex (index = p1I + 1). Now, we need to
        % add the difference between the requested and real distance (de1)
        % to point p1I, going in a line towards p1I + 1. Therefore, we need
        % to solve the differences between the requested and real x & y
        % (dx1 & dy1). Remember the requested x & y lie on the slope
        % between point p1I and p1I + 1. Therefore, dy1 = m * dx1 where m
        % is the slope. We want to solve de1 = sqrt(dx1^2 + dy1^2).
        % Plugging in m, we get de1 = sqrt(dx1^2 + (m*dx1)^2). Then
        % re-arrange the equality to solve:
        %
        % dx1 = de1/sqrt(1 + m^2) and dy1 = de1/sqrt(1 + (1/m)^2)
        %
        % But, Matlab uses (r,c) = (y,x), so x & y are reversed.
         */
        
        de1 = e1 - edgeLength;
        nextP1I =  (p1I < lastArrayIndex) ? p1I + 1 : p1I + 1 - lastArrayIndex;
        computeFractionalPixel(points, pointsNumber, de1, nextP1I, p1I, p1);
        
        //mexPrintf("%i, %f, %i, %i\n", pointsNumber, de1, nextP1I, p1I);
        //mexPrintf("%f, %f\n", p1[0], p1[1]);
        
        // Compute fractional pixels for the second edge (uses the previous pixel).
        de2 = e2 - edgeLength;
        prevP2I =  (p2I > 0) ? p2I - 1 : p2I - 1 + lastArrayIndex;
        computeFractionalPixel(points, pointsNumber, de2, prevP2I, p2I, p2);
        
        // Use the difference in tangents to measure the angle.
        a2 = atan2(points[pvI] - p2[0], points[pvI + pointsNumber] - p2[1]);
        a1 = atan2(p1[0] - points[pvI], p1[1] - points[pvI + pointsNumber]);
        angles[pvI] = a2-a1;
        
        mexPrintf("P1 = %f, %f\n", p1[0], p1[1]);
        mexPrintf("P2 = %f, %f\n", p2[0], p2[1]);
        
        if (angles[pvI] > M_PI)
            angles[pvI] = angles[pvI] - 2 * M_PI;
        else
            if (angles[pvI] < -1*M_PI)
                angles[pvI] = angles[pvI] + 2 * M_PI;
        
        angles[pvI] = angles[pvI] * 180 / M_PI;
        
        mexPrintf("%f\n", angles[pvI]);
        
        // Advance.
        pvI = pvI + 1;
        
        // Compute the first edge length.
        if (pvI <= lastArrayIndex)
        {
            if (p1I <= pvI)
                e1 = chainCodeLengths[pvI] - chainCodeLengths[p1I];
            else  // Compute the wrapped, second edge length.
                e1 = chainCodeLengths[lastArrayIndex] + chainCodeLengths[pvI] - chainCodeLengths[p1I];
            
            
            // Find the first edge.
            nextE1 = e1;
            nextP1I = p1I;
            
            mexPrintf("%f, %i\n", e1, p1I);
            mexPrintf("%f, %i\n", nextE1, nextP1I);
            mexPrintf("%i, %i\n", nextP1I, p1I);
            
            while (nextE1 > edgeLength)
            {
                // Advance.
                e1 = nextE1;
                p1I = nextP1I;
                nextP1I = p1I + 1;
                
                // Wrap.
                if (nextP1I > lastArrayIndex)
                    nextP1I = nextP1I - lastArrayIndex;
                
                // Compute the first edge length.
                if (nextP1I <= pvI)
                    nextE1 = chainCodeLengths[pvI] - chainCodeLengths[nextP1I];
                else // Compute the wrapped, second edge length.
                    nextE1 = chainCodeLengths[lastArrayIndex] + chainCodeLengths[pvI] - chainCodeLengths[nextP1I];
                
            }
            mexPrintf("%f, %i\n", nextE1, nextP1I);
        }
    }
}